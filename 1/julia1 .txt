{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[32m\u001b[1m    Updating\u001b[22m\u001b[39m registry at `C:\\Users\\issan\\.julia\\registries\\General.toml`\n",
      "\u001b[32m\u001b[1m   Resolving\u001b[22m\u001b[39m package versions...\n",
      "\u001b[32m\u001b[1m   Resolving\u001b[22m\u001b[39m package versions...\n",
      "\u001b[36m\u001b[1m     Project\u001b[22m\u001b[39m No packages added to or removed from `C:\\Users\\issan\\.julia\\environments\\v1.12\\Project.toml`\n",
      "\u001b[36m\u001b[1m    Manifest\u001b[22m\u001b[39m No packages added to or removed from `C:\\Users\\issan\\.julia\\environments\\v1.12\\Manifest.toml`\n",
      "\u001b[36m\u001b[1m     Project\u001b[22m\u001b[39m No packages added to or removed from `C:\\Users\\issan\\.julia\\environments\\v1.12\\Project.toml`\n",
      "\u001b[36m\u001b[1m    Manifest\u001b[22m\u001b[39m No packages added to or removed from `C:\\Users\\issan\\.julia\\environments\\v1.12\\Manifest.toml`\n"
     ]
    },
    {
     "data": {
      "application/vnd.webio.node+json": {
       "children": [],
       "instanceArgs": {
        "namespace": "html",
        "tag": "div"
       },
       "nodeType": "DOM",
       "props": {},
       "type": "node"
      },
      "text/html": [
       "<div style=\"padding: 1em; background-color: #f8d6da; border: 1px solid #f5c6cb; font-weight: bold;\">\n",
       "<p>The WebIO Jupyter extension was not detected. See the\n",
       "<a href=\"https://juliagizmos.github.io/WebIO.jl/latest/providers/ijulia/\" target=\"_blank\">\n",
       "    WebIO Jupyter integration documentation\n",
       "</a>\n",
       "for more information.\n",
       "</div>\n"
      ],
      "text/plain": [
       "WebIO._IJuliaInit()"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"graphs\""
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 1) （必要なら）パッケージ導入\n",
    "import Pkg; Pkg.add([\"Plots\",\"PlotlyJS\"])\n",
    "\n",
    "# 2) 新規セッションで実行\n",
    "import Plots, PlotlyJS, Random\n",
    "Plots.plotlyjs()                          # バックエンド固定\n",
    "Base.Filesystem.mkpath(\"graphs\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "using LinearAlgebra, Statistics, Random\n",
    "using Statistics, Printf\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "7flWn22p53-A"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "=== Experiment 1: Gaussian Elimination ===\n",
      "     N | median_residual |        median_relerr | median_time(s)\n",
      "-----------------------------------------------------------------\n",
      "   100 |    5.623688e-14 |         1.585626e-14 |     0.002255\n",
      "   200 |    2.305625e-13 |         3.506670e-14 |     0.016082\n",
      "   400 |    1.055894e-12 |         1.123654e-13 |     0.178846\n",
      "   800 |    3.826177e-12 |         2.134062e-13 |     1.201175\n",
      "-----------------------------------------------------------------\n",
      "   100 |    5.623688e-14 |         1.585626e-14 |     0.002255\n",
      "   200 |    2.305625e-13 |         3.506670e-14 |     0.016082\n",
      "   400 |    1.055894e-12 |         1.123654e-13 |     0.178846\n",
      "   800 |    3.826177e-12 |         2.134062e-13 |     1.201175\n"
     ]
    }
   ],
   "source": [
    "\n",
    "function gaussian_elimination(A)\n",
    "    A = float.(copy(A))\n",
    "    n = size(A, 1)\n",
    "    for k = 1:n-1\n",
    "        pivot = k - 1 + argmax(abs.(A[k:end, k]))\n",
    "        if pivot != k\n",
    "            A[k, :], A[pivot, :] = A[pivot, :], A[k, :]\n",
    "        end\n",
    "        for i = k+1:n\n",
    "            if A[i,k] != 0\n",
    "                factor = A[i,k] / A[k,k]\n",
    "                A[i, k:end] .-= factor .* A[k, k:end]\n",
    "            end\n",
    "        end\n",
    "    end\n",
    "    A\n",
    "end\n",
    "\n",
    "function back_substitution(A) # [U b]\n",
    "    n = size(A, 1)\n",
    "    x = zeros(eltype(A), n)\n",
    "    for i = n:-1:1\n",
    "        x[i] = A[i, n+1]\n",
    "        for j = i+1:n\n",
    "            x[i] -= A[i, j] * x[j]\n",
    "        end\n",
    "        x[i] /= A[i, i]\n",
    "    end\n",
    "    x\n",
    "end\n",
    "\n",
    "function exp1(N; num_trials=100)\n",
    "    residuals = zeros(num_trials)\n",
    "    relerrs   = zeros(num_trials)\n",
    "    times     = zeros(num_trials)\n",
    "    for t in 1:num_trials\n",
    "        A = rand(N,N); b = rand(N)\n",
    "        C = hcat(A,b)\n",
    "        times[t] = @elapsed begin\n",
    "            U = gaussian_elimination(C)\n",
    "            x̂ = back_substitution(U)\n",
    "            xref = A \\ b\n",
    "            residuals[t] = norm(A*x̂ - b)\n",
    "            relerrs[t]   = norm(x̂ - xref) / norm(xref)\n",
    "        end\n",
    "    end\n",
    "    (; residuals, relerrs, times,\n",
    "       res_median=median(residuals), rel_median=median(relerrs), time_median=median(times))\n",
    "end\n",
    "\n",
    "function plot_exp1(N; num_trials=100, saveprefix=\"exp1_n$(N)\")\n",
    "    r = exp1(N; num_trials=num_trials)\n",
    "    t = 1:num_trials\n",
    "    medianline(v) = fill(v, num_trials)\n",
    "\n",
    "    p1 = Plots.scatter(t, r.residuals; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"residual norm\",\n",
    "        title=\"Residual norm by elimination  n=$N\")\n",
    "    Plots.plot!(p1, t, medianline(r.res_median); l=:dash)\n",
    "    Plots.annotate!(p1, [(50, r.res_median, Plots.text(\"$(round(r.res_median, sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p1, \"graphs/$(saveprefix)_residual.png\")\n",
    "\n",
    "    p2 = Plots.scatter(t, r.relerrs; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"relative error\",\n",
    "        title=\"Relative error by elimination  n=$N\")\n",
    "    Plots.plot!(p2, t, medianline(r.rel_median); l=:dash)\n",
    "    Plots.annotate!(p2, [(50, r.rel_median, Plots.text(\"$(round(r.rel_median, sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p2, \"graphs/$(saveprefix)_relerr_solution.png\")\n",
    "\n",
    "    p3 = Plots.scatter(t, r.times; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"time [sec]\",\n",
    "        title=\"Runtime by elimination  n=$N\")\n",
    "    Plots.plot!(p3, t, medianline(r.time_median); l=:dash)\n",
    "    Plots.annotate!(p3, [(50, r.time_median, Plots.text(\"$(round(r.time_median, sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p3, \"graphs/$(saveprefix)_time.png\")\n",
    "    \n",
    "    return (r.res_median, r.rel_median, r.time_median)\n",
    "end\n",
    "\n",
    "# Run experiments and save results\n",
    "Ns_exp1 = [100, 200, 400, 800]\n",
    "results_exp1 = []\n",
    "\n",
    "for N in Ns_exp1\n",
    "    m_res, m_rel, m_time = plot_exp1(N; num_trials=100)\n",
    "    push!(results_exp1, (N, m_res, m_rel, m_time))\n",
    "end\n",
    "\n",
    "# Print table from saved results\n",
    "@printf(\"\\n=== Experiment 1: Gaussian Elimination ===\\n\")\n",
    "@printf(\"%6s | %15s | %20s | %12s\\n\", \"N\", \"median_residual\", \"median_relerr\", \"median_time(s)\")\n",
    "println(repeat(\"-\", 65))\n",
    "for (N, m_res, m_rel, m_time) in results_exp1\n",
    "    @printf(\"%6d | %15.6e | %20.6e | %12.6f\\n\", N, m_res, m_rel, m_time)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "SOVyO1B5S8L1"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "=== Experiment 2: LU Decomposition ===\n",
      "     N |   mean_residual |          mean_relerr | mean_time(s)\n",
      "-----------------------------------------------------------------\n",
      "   100 |    5.164309e-13 |         9.662916e-14 |     0.003669\n",
      "   200 |    8.582994e-13 |         1.940446e-13 |     0.016455\n",
      "   400 |    4.783407e-12 |         3.254845e-13 |     0.201206\n",
      "   800 |    1.209820e-11 |         5.947384e-13 |     1.542728\n"
     ]
    }
   ],
   "source": [
    "# ===== LU with partial pivoting (no built-ins) =====\n",
    "\n",
    "# Forward/Backward substitution\n",
    "function forward_sub(L, b)\n",
    "    n = size(L,1)\n",
    "    y = similar(b, n)\n",
    "    for i = 1:n\n",
    "        s = zero(eltype(L))\n",
    "        for j = 1:i-1\n",
    "            s += L[i,j]*y[j]\n",
    "        end\n",
    "        y[i] = (b[i] - s) / L[i,i]\n",
    "    end\n",
    "    y\n",
    "end\n",
    "\n",
    "function backward_sub(U, y)\n",
    "    n = size(U,1)\n",
    "    x = similar(y, n)\n",
    "    for i = n:-1:1\n",
    "        s = zero(eltype(U))\n",
    "        for j = i+1:n\n",
    "            s += U[i,j]*x[j]\n",
    "        end\n",
    "        x[i] = (y[i] - s) / U[i,i]\n",
    "    end\n",
    "    x\n",
    "end\n",
    "\n",
    "# LU (Doolittle) with partial pivoting: P*A = L*U\n",
    "function lu_pp(Ain)\n",
    "    U = float.(copy(Ain))\n",
    "    n = size(U,1)\n",
    "    L = Matrix{eltype(U)}(I, n, n)\n",
    "    p = collect(1:n)  # permutation vector representing P\n",
    "\n",
    "    for k = 1:n-1\n",
    "        # pivot search\n",
    "        piv = k - 1 + argmax(abs.(U[k:end, k]))\n",
    "        if abs(U[piv, k]) == 0\n",
    "            error(\"Matrix is singular to working precision.\")\n",
    "        end\n",
    "        # row swap in U and the accumulated part of L, and record permutation\n",
    "        if piv != k\n",
    "            U[k, :], U[piv, :] = U[piv, :], U[k, :]\n",
    "            if k > 1\n",
    "                L[k, 1:k-1], L[piv, 1:k-1] = L[piv, 1:k-1], L[k, 1:k-1]\n",
    "            end\n",
    "            p[k], p[piv] = p[piv], p[k]\n",
    "        end\n",
    "        # elimination\n",
    "        for i = k+1:n\n",
    "            L[i, k] = U[i, k] / U[k, k]\n",
    "            U[i, k:end] .-= L[i, k] .* U[k, k:end]\n",
    "        end\n",
    "    end\n",
    "    return L, U, p  # so that P*b == b[p]\n",
    "end\n",
    "\n",
    "# Solve A x = b using our LU with pivoting\n",
    "function lu_solve(A, b)\n",
    "    L, U, p = lu_pp(A)\n",
    "    bp = b[p]               # apply permutation P to b\n",
    "    y  = forward_sub(L, bp) # solve L y = P b\n",
    "    x  = backward_sub(U, y) # solve U x = y\n",
    "    return x\n",
    "end\n",
    "\n",
    "# ===== Experiment 2 (manual LU) =====\n",
    "function exp2(N; num_trials=100)\n",
    "    residuals = zeros(num_trials)\n",
    "    relerrs   = zeros(num_trials)\n",
    "    times     = zeros(num_trials)\n",
    "\n",
    "    for t in 1:num_trials\n",
    "        A = rand(N,N); b = rand(N)\n",
    "        xref = A \\ b  # reference by Julia solver\n",
    "\n",
    "        times[t] = @elapsed begin\n",
    "            xhat = lu_solve(A, b)\n",
    "            residuals[t] = norm(A*xhat - b)\n",
    "            relerrs[t]   = norm(xhat - xref) / norm(xref)\n",
    "        end\n",
    "    end\n",
    "\n",
    "    (; residuals, relerrs, times,\n",
    "       res_median = median(residuals),\n",
    "       rel_median = median(relerrs),\n",
    "       time_median = median(times))\n",
    "end\n",
    "\n",
    "# Plot wrapper (英語表示)\n",
    "function plot_exp2(N; num_trials=100, saveprefix=\"exp2_n$(N)\")\n",
    "    r = exp2(N; num_trials=num_trials)\n",
    "    t = 1:num_trials\n",
    "    medianline(v) = fill(v, num_trials)\n",
    "\n",
    "    p1 = Plots.scatter(t, r.residuals; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"residual norm\",\n",
    "        title=\"Residual norm by LU (manual)  n=$N\")\n",
    "    Plots.plot!(p1, t, medianline(r.res_median); l=:dash)\n",
    "    Plots.annotate!(p1, [(50, r.res_median, Plots.text(\"$(round(r.res_median, sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p1, \"graphs/$(saveprefix)_residual.png\")\n",
    "\n",
    "    p2 = Plots.scatter(t, r.relerrs; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"relative error\",\n",
    "        title=\"Relative error by LU (manual)  n=$N\")\n",
    "    Plots.plot!(p2, t, medianline(r.rel_median); l=:dash)\n",
    "    Plots.annotate!(p2, [(50, r.rel_median, Plots.text(\"$(round(r.rel_median, sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p2, \"graphs/$(saveprefix)_relerr_solution.png\")\n",
    "\n",
    "    p3 = Plots.scatter(t, r.times; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"time [sec]\",\n",
    "        title=\"Runtime by LU (manual)  n=$N\")\n",
    "    Plots.plot!(p3, t, medianline(r.time_median); l=:dash)\n",
    "    Plots.annotate!(p3, [(50, r.time_median, Plots.text(\"$(round(r.time_median, sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p3, \"graphs/$(saveprefix)_time.png\")\n",
    "    \n",
    "    return (r.res_median, r.rel_median, r.time_median)\n",
    "end\n",
    "\n",
    "# Run experiments and save results\n",
    "Ns_exp2 = [100, 200, 400, 800]\n",
    "results_exp2 = []\n",
    "\n",
    "for N in Ns_exp2\n",
    "    m_res, m_rel, m_time = plot_exp2(N; num_trials=100)\n",
    "    push!(results_exp2, (N, m_res, m_rel, m_time))\n",
    "end\n",
    "\n",
    "# Print table from saved results\n",
    "@printf(\"\\n=== Experiment 2: LU Decomposition ===\\n\")\n",
    "@printf(\"%6s | %15s | %20s | %12s\\n\", \"N\", \"median_residual\", \"median_relerr\", \"median_time(s)\")\n",
    "println(repeat(\"-\", 65))\n",
    "for (N, m_res, m_rel, m_time) in results_exp2\n",
    "    @printf(\"%6d | %15.6e | %20.6e | %12.6f\\n\", N, m_res, m_rel, m_time)\n",
    "end\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "T0aTyPmHxMpn"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "=== Experiment 3: Power Iteration ===\n",
      "     N |   mean_residual |   mean_relerr_lambda |        mean_relerr_v | mean_time(s) | mean_iters\n",
      "-----------------------------------------------------------------------------------------------\n",
      "    50 |    4.539834e-05 |         1.260439e+00 |         8.626725e-01 |     0.001079 |     496.35\n",
      "   100 |    2.154136e-02 |         9.564959e-01 |         6.653471e-01 |     0.004730 |    1216.28\n",
      "   200 |    8.754630e-02 |         1.011761e+00 |         7.065992e-01 |     0.023573 |    1830.74\n",
      "   400 |    8.676567e-02 |         1.227463e+00 |         8.615130e-01 |     0.098008 |    1974.48\n"
     ]
    }
   ],
   "source": [
    "function powEigen(A, max_iter = 10000, tol = 1e-12)\n",
    "    n = size(A, 1)\n",
    "    b_k = rand(n)\n",
    "    b_k /= norm(b_k)\n",
    "    itr = 0\n",
    "    for iter in 1:max_iter\n",
    "        itr += 1\n",
    "        # Calculate the matrix-by-vector product Ab\n",
    "        b_k1 = A * b_k\n",
    "\n",
    "        # Re-normalize the vector\n",
    "        b_k1_norm = norm(b_k1)\n",
    "        b_k1 /= b_k1_norm\n",
    "\n",
    "        # Check for convergence\n",
    "        if norm(b_k1 - b_k) < tol*norm(b_k)\n",
    "            break\n",
    "        end\n",
    "\n",
    "        b_k = b_k1\n",
    "    end\n",
    "\n",
    "    # Rayleigh quotient for eigenvalue approximation\n",
    "    eigenvalue = dot(b_k, A * b_k) / dot(b_k, b_k)\n",
    "    return eigenvalue, b_k, itr\n",
    "end\n",
    "\n",
    "function exp3(N; num_trials=100)\n",
    "    eigenvalues = zeros(num_trials)\n",
    "    times       = zeros(num_trials)\n",
    "    resnorms    = zeros(num_trials)\n",
    "    relerrs_lambda = zeros(num_trials)\n",
    "    relerrs_v      = zeros(num_trials)\n",
    "    itrs           = zeros(Int, num_trials)\n",
    "\n",
    "    for t in 1:num_trials\n",
    "        A = randn(N,N)\n",
    "        A = ( A + A' ) / 2\n",
    "        λref, vref = eigen(A).values[end], eigen(A).vectors[:, end]\n",
    "        times[t] = @elapsed begin\n",
    "            λ, v, itr = powEigen(A)\n",
    "        end\n",
    "        eigenvalues[t] = λ\n",
    "        itrs[t] = itr\n",
    "        resnorms[t] = norm(A*v - λ*v)\n",
    "        relerrs_lambda[t] = abs(λ - λref) / abs(λref)\n",
    "        \n",
    "        # Normalize both vectors and ensure same sign direction\n",
    "        v_normalized = v / norm(v)\n",
    "        vref_normalized = vref / norm(vref)\n",
    "        # Check if vectors point in opposite directions and flip if needed\n",
    "        if dot(v_normalized, vref_normalized) < 0\n",
    "            v_normalized = -v_normalized\n",
    "        end\n",
    "        relerrs_v[t] = norm(v_normalized - vref_normalized) / norm(vref_normalized)\n",
    "\n",
    "    end\n",
    "\n",
    "    (; resnorms, relerrs_lambda, relerrs_v, times, itrs)\n",
    "end\n",
    "\n",
    "function plot_exp3(N; num_trials=100, saveprefix=\"exp3_n$(N)\")\n",
    "    r = exp3(N; num_trials=num_trials)\n",
    "    t = 1:num_trials\n",
    "    medianline(v) = fill(v, num_trials)\n",
    "\n",
    "    p1 = Plots.scatter(t, r.resnorms; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"residual norm\",\n",
    "        title=\"Residual norm by Power Iteration  n=$N\")\n",
    "    Plots.plot!(p1, t, medianline(median(r.resnorms)); l=:dash)\n",
    "    Plots.annotate!(p1, [(50, median(r.resnorms), Plots.text(\"$(round(median(r.resnorms), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p1, \"graphs/$(saveprefix)_residual.png\")\n",
    "\n",
    "    p2 = Plots.scatter(t, r.relerrs_lambda; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"relative error (eigenvalue)\",\n",
    "        title=\"Relative error (eigenvalue) by Power Iteration  n=$N\")\n",
    "    Plots.plot!(p2, t, medianline(median(r.relerrs_lambda)); l=:dash)\n",
    "    Plots.annotate!(p2, [(50, median(r.relerrs_lambda), Plots.text(\"$(round(median(r.relerrs_lambda), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p2, \"graphs/$(saveprefix)_relerr_eigenvalue.png\")\n",
    "\n",
    "    p3 = Plots.scatter(t, r.relerrs_v; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"relative error (eigenvector)\",\n",
    "        title=\"Relative error (eigenvector) by Power Iteration  n=$N\")\n",
    "    Plots.plot!(p3, t, medianline(median(r.relerrs_v)); l=:dash)\n",
    "    Plots.annotate!(p3, [(50, median(r.relerrs_v), Plots.text(\"$(round(median(r.relerrs_v), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p3, \"graphs/$(saveprefix)_relerr_eigenvector.png\")\n",
    "\n",
    "    p4 = Plots.scatter(t, r.times; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"time [sec]\",\n",
    "        title=\"Runtime by Power Iteration  n=$N\")\n",
    "    Plots.plot!(p4, t, medianline(median(r.times)); l=:dash)\n",
    "    Plots.annotate!(p4, [(50, median(r.times), Plots.text(\"$(round(median(r.times), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p4, \"graphs/$(saveprefix)_time.png\")\n",
    "\n",
    "    p5 = Plots.scatter(t, r.itrs; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"iterations\",\n",
    "        title=\"Iterations by Power Iteration  n=$N\")\n",
    "    Plots.plot!(p5, t, medianline(median(r.itrs)); l=:dash)\n",
    "    Plots.annotate!(p5, [(50, median(r.itrs), Plots.text(\"$(round(median(r.itrs), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p5, \"graphs/$(saveprefix)_iterations.png\")\n",
    "    \n",
    "    return (median(r.resnorms), median(r.relerrs_lambda), median(r.relerrs_v), median(r.times), median(r.itrs))\n",
    "end\n",
    "\n",
    "# Run experiments and save results\n",
    "Ns_exp3 = [50, 100, 200, 400]\n",
    "results_exp3 = []\n",
    "\n",
    "for N in Ns_exp3\n",
    "    m_res, m_rel_lambda, m_rel_v, m_time, m_itrs = plot_exp3(N; num_trials=100)\n",
    "    push!(results_exp3, (N, m_res, m_rel_lambda, m_rel_v, m_time, m_itrs))\n",
    "end\n",
    "\n",
    "# Print table from saved results\n",
    "@printf(\"\\n=== Experiment 3: Power Iteration ===\\n\")\n",
    "@printf(\"%6s | %15s | %20s | %20s | %12s | %10s\\n\", \"N\", \"median_residual\", \"median_relerr_lambda\", \"median_relerr_v\", \"median_time(s)\", \"median_iters\")\n",
    "println(repeat(\"-\", 95))\n",
    "for (N, m_res, m_rel_lambda, m_rel_v, m_time, m_itrs) in results_exp3\n",
    "    @printf(\"%6d | %15.6e | %20.6e | %20.6e | %12.6f | %10.2f\\n\", N, m_res, m_rel_lambda, m_rel_v, m_time, m_itrs)\n",
    "end\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n",
      "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n",
      "\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils C:\\Users\\issan\\.julia\\packages\\PlotUtils\\dVEMd\\src\\ticks.jl:194\u001b[39m\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "=== Experiment 4: Power then Inverse Iteration ===\n",
      "     N |   mean_residual |   mean_relerr_lambda |        mean_relerr_v | mean_time(s) | mean_iters\n",
      "-----------------------------------------------------------------------------------------------\n",
      "    50 |    1.629618e-06 |         6.510854e-08 |         4.793259e-16 |     0.000057 |       7.00\n",
      "   100 |    1.375552e-06 |         2.742017e-08 |         4.681961e-16 |     0.000223 |       6.98\n",
      "   200 |    4.627855e-05 |         4.625105e-07 |         5.756233e-16 |     0.002310 |       6.00\n",
      "   400 |    2.357273e-05 |         1.177965e-07 |         6.564195e-16 |     0.011748 |       6.00\n"
     ]
    }
   ],
   "source": [
    "function pow_andthen_invEigen(A, min_turning_iter= 50, max_iter = 1000, tol = 1e-12)\n",
    "    n = size(A, 1)\n",
    "    b_k = rand(n)\n",
    "    b_k /= norm(b_k)\n",
    "    itr = 0\n",
    "    L = Matrix{eltype(A)}(I, n, n)\n",
    "    mu = 0.0\n",
    "    for iter in 1:min_turning_iter\n",
    "        itr += 1\n",
    "        # Calculate the matrix-by-vector product Ab\n",
    "        b_k1 = A * b_k\n",
    "\n",
    "        # Re-normalize the vector\n",
    "        b_k1_norm = norm(b_k1)\n",
    "        b_k1 /= b_k1_norm\n",
    "        if norm(b_k1 - b_k) < 0.001*norm(b_k)\n",
    "            break\n",
    "        end\n",
    "        b_k = b_k1\n",
    "\n",
    "    end\n",
    "    mu = dot(b_k, A * b_k) / dot(b_k, b_k)  # Rayleigh quotient for eigenvalue approximation\n",
    "    # b_kリセット\n",
    "    b_k = rand(n)\n",
    "    b_k /= norm(b_k)\n",
    "    F = lu(A - mu * I)\n",
    "    for iter in 1:(max_iter - min_turning_iter)\n",
    "        itr += 1\n",
    "        # Solve (A - mu*I) y = b_k\n",
    "        y = F \\ b_k\n",
    "\n",
    "        # Re-normalize the vector\n",
    "        y_norm = norm(y)\n",
    "        b_k1 = y / y_norm\n",
    "\n",
    "        # Check for convergence\n",
    "        if norm(b_k1 - b_k) < tol*norm(b_k)\n",
    "            b_k = b_k1\n",
    "            break\n",
    "        end\n",
    "\n",
    "        b_k = b_k1\n",
    "    end\n",
    "    return mu, b_k, itr\n",
    "end\n",
    "\n",
    "function exp4(N;num_trials=100)\n",
    "    eigenvalues = zeros(num_trials)\n",
    "    times       = zeros(num_trials)\n",
    "    resnorms    = zeros(num_trials)\n",
    "    relerrs_lambda = zeros(num_trials)\n",
    "    relerrs_v      = zeros(num_trials)\n",
    "    itrs           = zeros(Int, num_trials)\n",
    "\n",
    "    for t in 1:num_trials\n",
    "        A = randn(N,N)\n",
    "        A = (A + A') / 2\n",
    "        λref, vref = eigen(A).values[end], eigen(A).vectors[:, end]\n",
    "        times[t] = @elapsed begin\n",
    "            λ, v, itr = pow_andthen_invEigen(A)\n",
    "        end\n",
    "        eigenvalues[t] = λ\n",
    "        itrs[t] = itr\n",
    "        resnorms[t] = norm(A*v - λ*v)\n",
    "        relerrs_lambda[t] = abs(λ - λref) / abs(λref)\n",
    "        \n",
    "        # Normalize both vectors and ensure same sign direction\n",
    "        v_normalized = v / norm(v)\n",
    "        vref_normalized = vref / norm(vref)\n",
    "        # Check if vectors point in opposite directions and flip if needed\n",
    "        if dot(v_normalized, vref_normalized) < 0\n",
    "            v_normalized = -v_normalized\n",
    "        end\n",
    "        relerrs_v[t] = norm(v_normalized - vref_normalized) / norm(vref_normalized)\n",
    "\n",
    "    end\n",
    "\n",
    "    (; resnorms, relerrs_lambda, relerrs_v, times, itrs)\n",
    "\n",
    "    \n",
    "end\n",
    "\n",
    "function plot_exp4(N; num_trials=100, saveprefix=\"exp4_n$(N)\")\n",
    "    r = exp4(N; num_trials=num_trials)\n",
    "    t = 1:num_trials\n",
    "    medianline(v) = fill(v, num_trials)\n",
    "\n",
    "    p1 = Plots.scatter(t, r.resnorms; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"residual norm\",\n",
    "        title=\"Residual norm by Power then Inverse Iteration  n=$N\")\n",
    "    Plots.plot!(p1, t, medianline(median(r.resnorms)); l=:dash)\n",
    "    Plots.annotate!(p1, [(50, median(r.resnorms), Plots.text(\"$(round(median(r.resnorms), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p1, \"graphs/$(saveprefix)_residual.png\")\n",
    "\n",
    "    p2 = Plots.scatter(t, r.relerrs_lambda; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"relative error (eigenvalue)\",\n",
    "        title=\"Relative error (eigenvalue) by Power then Inverse Iteration  n=$N\")\n",
    "    Plots.plot!(p2, t, medianline(median(r.relerrs_lambda)); l=:dash)\n",
    "    Plots.annotate!(p2, [(50, median(r.relerrs_lambda), Plots.text(\"$(round(median(r.relerrs_lambda), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p2, \"graphs/$(saveprefix)_relerr_eigenvalue.png\")\n",
    "\n",
    "    p3 = Plots.scatter(t, r.relerrs_v; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"relative error (eigenvector)\",\n",
    "        title=\"Relative error (eigenvector) by Power then Inverse Iteration  n=$N\")\n",
    "    Plots.plot!(p3, t, medianline(median(r.relerrs_v)); l=:dash)\n",
    "    Plots.annotate!(p3, [(50, median(r.relerrs_v), Plots.text(\"$(round(median(r.relerrs_v), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p3, \"graphs/$(saveprefix)_relerr_eigenvector.png\")\n",
    "\n",
    "    p4 = Plots.scatter(t, r.times; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"time [sec]\",\n",
    "        title=\"Runtime by Power then Inverse Iteration  n=$N\")\n",
    "    Plots.plot!(p4, t, medianline(median(r.times)); l=:dash)\n",
    "    Plots.annotate!(p4, [(50, median(r.times), Plots.text(\"$(round(median(r.times), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p4, \"graphs/$(saveprefix)_time.png\")\n",
    "\n",
    "    p5 = Plots.scatter(t, r.itrs; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"iterations\",\n",
    "        title=\"Iterations by Power then Inverse Iteration  n=$N\")\n",
    "    Plots.plot!(p5, t, medianline(median(r.itrs)); l=:dash)\n",
    "    Plots.annotate!(p5, [(50, median(r.itrs), Plots.text(\"$(round(median(r.itrs), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p5, \"graphs/$(saveprefix)_iterations.png\")\n",
    "    \n",
    "    return (median(r.resnorms), median(r.relerrs_lambda), median(r.relerrs_v), median(r.times), median(r.itrs))\n",
    "end\n",
    "\n",
    "# Run experiments and save results\n",
    "Ns_exp4 = [50, 100, 200, 400]\n",
    "results_exp4 = []\n",
    "\n",
    "for N in Ns_exp4\n",
    "    m_res, m_rel_lambda, m_rel_v, m_time, m_itrs = plot_exp4(N; num_trials=100)\n",
    "    push!(results_exp4, (N, m_res, m_rel_lambda, m_rel_v, m_time, m_itrs))\n",
    "end\n",
    "\n",
    "# Print table from saved results\n",
    "@printf(\"\\n=== Experiment 4: Power then Inverse Iteration ===\\n\")\n",
    "@printf(\"%6s | %15s | %20s | %20s | %12s | %10s\\n\", \"N\", \"median_residual\", \"median_relerr_lambda\", \"median_relerr_v\", \"median_time(s)\", \"median_iters\")\n",
    "println(repeat(\"-\", 95))\n",
    "for (N, m_res, m_rel_lambda, m_rel_v, m_time, m_itrs) in results_exp4\n",
    "    @printf(\"%6d | %15.6e | %20.6e | %20.6e | %12.6f | %10.2f\\n\", N, m_res, m_rel_lambda, m_rel_v, m_time, m_itrs)\n",
    "end\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "qr_manual (generic function with 1 method)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function qr_manual(A)\n",
    "    n = size(A, 1)\n",
    "    Q = copy(A)\n",
    "    R = Matrix{eltype(A)}(I, n, n)\n",
    "    # Gram–Schmidt\n",
    "    for k = 1:n\n",
    "        for j = 1:k-1\n",
    "            R[j, k] = dot(Q[:, j], Q[:, k])\n",
    "            Q[:, k] .-= R[j, k] * Q[:, j]\n",
    "        end\n",
    "        R[k, k] = norm(Q[:, k])\n",
    "        Q[:, k] /= R[k, k]\n",
    "    end\n",
    "    return Q, R\n",
    "\n",
    "end\n",
    "\n",
    "\n",
    "function invEigen(A, mu, max_iter=1000, tol=1e-12)\n",
    "    n = size(A, 1)\n",
    "    ε = 1e-6  # Increase shift to avoid near-singular matrices\n",
    "    \n",
    "    # Create shifted matrix and check for NaN/Inf\n",
    "    A_shifted = A - (mu + ε) * I\n",
    "    if any(isnan, A_shifted) || any(isinf, A_shifted)\n",
    "        # If matrix is bad, return approximate eigenvector\n",
    "        b_k = rand(n)\n",
    "        b_k /= norm(b_k)\n",
    "        λ = dot(b_k, A * b_k) / dot(b_k, b_k)\n",
    "        return λ, b_k\n",
    "    end\n",
    "    \n",
    "    # Try LU factorization with error handling\n",
    "    try\n",
    "        F = lu(A_shifted)\n",
    "        b_k = rand(n)\n",
    "        b_k /= norm(b_k)\n",
    "        for _ in 1:max_iter\n",
    "            y = F \\ b_k\n",
    "            # Check for NaN/Inf in result\n",
    "            if any(isnan, y) || any(isinf, y)\n",
    "                break\n",
    "            end\n",
    "            y /= norm(y)\n",
    "            if norm(y - b_k) < tol\n",
    "                b_k = y\n",
    "                break\n",
    "            end\n",
    "            b_k = y\n",
    "        end\n",
    "        λ = dot(b_k, A * b_k) / dot(b_k, b_k)\n",
    "        return λ, b_k\n",
    "    catch e\n",
    "        # If LU fails, use a random vector as approximation\n",
    "        b_k = rand(n)\n",
    "        b_k /= norm(b_k)\n",
    "        λ = dot(b_k, A * b_k) / dot(b_k, b_k)\n",
    "        return λ, b_k\n",
    "    end\n",
    "end\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "function qrEigens(A; max_iter=100000, tol=1e-10)\n",
    "    n = size(A, 1)\n",
    "    Ak = copy(A)\n",
    "    eigenvectors = Matrix{Float64}(I, n, n)  \n",
    "    itr = 0\n",
    "    for k in 1:max_iter\n",
    "        itr += 1\n",
    "        Q, R = qr_manual(Ak)\n",
    "        Ak1 = R * Q\n",
    "        if norm(Ak1 - Ak, Inf) < tol * norm(Ak, Inf)\n",
    "            break\n",
    "        end\n",
    "        Ak = Ak1\n",
    "    end\n",
    "    eigenvalues = diag(Ak)\n",
    "    for k in 1:n\n",
    "        mu = eigenvalues[k]\n",
    "        _, v_k= invEigen(A, mu, max_iter, tol)\n",
    "    end\n",
    "    return eigenvalues, eigenvectors, itr\n",
    "end\n",
    "\n",
    "function exp5(N; num_trials=100)\n",
    "    eigenvalues = zeros(num_trials, N)\n",
    "    times       = zeros(num_trials)\n",
    "    max_resnorms    = zeros(num_trials)\n",
    "    max_relerrs_lambda = zeros(num_trials)\n",
    "    itrs           = zeros(Int, num_trials)\n",
    "\n",
    "    for t in 1:num_trials\n",
    "        A = rand(N,N)\n",
    "        A = (A + A') / 2\n",
    "        λref = sort(eigen(A).values)\n",
    "        times[t] = @elapsed begin\n",
    "            λ, V, itr = qrEigens(A)\n",
    "        end\n",
    "        eigenvalues[t, :] = λ\n",
    "        itrs[t] = itr\n",
    "        \n",
    "        # 式(2.58): max_i ||(A - λ_i I)v_i||\n",
    "        resnorms_i = zeros(N)\n",
    "        for i in 1:N\n",
    "            v_i = V[:, i]\n",
    "            resnorms_i[i] = norm(A * v_i - λ[i] * v_i)\n",
    "        end\n",
    "        max_resnorms[t] = maximum(resnorms_i)\n",
    "        \n",
    "        # 式(2.59): max_i |λ_i - λ̂_i| / |λ_i|\n",
    "        λ_sorted = sort(λ)\n",
    "        relerrs_i = abs.(λ_sorted .- λref) ./ abs.(λref)\n",
    "        max_relerrs_lambda[t] = maximum(relerrs_i)\n",
    "    end\n",
    "\n",
    "    (; max_resnorms, max_relerrs_lambda, times, itrs)\n",
    "end\n",
    "\n",
    "function plot_exp5(N; num_trials=10, saveprefix=\"exp5_n$(N)\")\n",
    "    r = exp5(N; num_trials=num_trials)\n",
    "    t = 1:num_trials\n",
    "    medianline(v) = fill(v, num_trials)\n",
    "\n",
    "    p1 = Plots.scatter(t, r.max_resnorms; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"max residual norm\",\n",
    "        title=\"Max Residual norm by QR Algorithm  n=$N\")\n",
    "    Plots.plot!(p1, t, medianline(median(r.max_resnorms)); l=:dash)\n",
    "    # Plots.annotate!(p1, [(50, median(r.max_resnorms), Plots.text(\"$(round(median(r.max_resnorms), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p1, \"graphs/$(saveprefix)_max_residual.png\")\n",
    "\n",
    "    p2 = Plots.scatter(t, r.max_relerrs_lambda; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"max relative error (eigenvalue)\",\n",
    "        title=\"Max Relative error (eigenvalue) by QR Algorithm  n=$N\")\n",
    "    Plots.plot!(p2, t, medianline(median(r.max_relerrs_lambda)); l=:dash)\n",
    "    # Plots.annotate!(p2, [(50, median(r.max_relerrs_lambda), Plots.text(\"$(round(median(r.max_relerrs_lambda), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p2, \"graphs/$(saveprefix)_max_relerr_eigenvalue.png\")\n",
    "\n",
    "    p3 = Plots.scatter(t, r.times; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"time [sec]\",\n",
    "        title=\"Runtime by QR Algorithm  n=$N\")\n",
    "    Plots.plot!(p3, t, medianline(median(r.times)); l=:dash)\n",
    "    # Plots.annotate!(p3, [(50, median(r.times), Plots.text(\"$(round(median(r.times), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p3, \"graphs/$(saveprefix)_time.png\")\n",
    "\n",
    "    p4 = Plots.scatter(t, r.itrs; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"iterations\",\n",
    "        title=\"Iterations by QR Algorithm  n=$N\")\n",
    "    Plots.plot!(p4, t, medianline(median(r.itrs)); l=:dash)\n",
    "    # Plots.annotate!(p4, [(50, median(r.itrs), Plots.text(\"$(round(median(r.itrs), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p4, \"graphs/$(saveprefix)_iterations.png\")\n",
    "    \n",
    "    return (median(r.max_resnorms), median(r.max_relerrs_lambda), median(r.times), median(r.itrs))\n",
    "end\n",
    "\n",
    "# Run experiments and save results\n",
    "Ns_exp5 = [10, 20, 40, 80]\n",
    "results_exp5 = []\n",
    "\n",
    "for N in Ns_exp5\n",
    "    m_res, m_rel, m_time, m_itrs = plot_exp5(N; num_trials=10)\n",
    "    push!(results_exp5, (N, m_res, m_rel, m_time, m_itrs))\n",
    "end\n",
    "\n",
    "# Print table from saved results\n",
    "@printf(\"\\n=== Experiment 5: QR Algorithm ===\\n\")\n",
    "@printf(\"%6s | %15s | %20s | %12s | %10s\\n\", \"N\", \"median_max_resnorm\", \"median_max_relerr_lambda\", \"median_time(s)\", \"median_iters\")\n",
    "println(repeat(\"-\", 80))\n",
    "for (N, m_res, m_rel, m_time, m_itrs) in results_exp5\n",
    "    @printf(\"%6d | %15.6e | %20.6e | %12.6f | %10.2f\\n\", N, m_res, m_rel, m_time, m_itrs)\n",
    "end\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "     N |    mean_resnorm | mean_relerr_eigenvalue | mean_time(s) | mean_iters\n",
      "--------------------------------------------------------------------------------\n",
      "    10 |    2.501506e-15 |         3.043254e-14 |     0.006180 |      22.24\n",
      "    20 |    5.430818e-15 |         7.038863e-14 |     0.022716 |      45.97\n",
      "    40 |    1.527971e-14 |         6.184411e-14 |     0.086108 |      90.04\n",
      "    80 |    4.051939e-14 |         1.488087e-13 |     0.454530 |     174.25\n"
     ]
    }
   ],
   "source": [
    "\n",
    "function qrEigens_fast(A; max_iter=100000, tol=1e-10)\n",
    "    # シフトと減次を用いて高速化\n",
    "    n = size(A, 1)\n",
    "    Ak = copy(A)\n",
    "    itr = 0\n",
    "    mu = 0.0\n",
    "    dimension = n\n",
    "    eigenvalues = zeros(n)\n",
    "    eigenvectors = Matrix{Float64}(I, n, n)\n",
    "    \n",
    "    for k in 1:max_iter\n",
    "        itr += 1\n",
    "        # Check for deflation\n",
    "        L = Matrix{eltype(Ak)}(I, dimension, dimension)\n",
    "        if norm((Ak-mu*L)[dimension, 1:dimension-1], 1) < tol\n",
    "            eigenvalues[dimension] = Ak[dimension, dimension]\n",
    "            dimension -= 1\n",
    "            Ak = Ak[1:dimension, 1:dimension]\n",
    "            L = L[1:dimension, 1:dimension]\n",
    "            if dimension == 0\n",
    "                break\n",
    "            end\n",
    "        end\n",
    "        \n",
    "        mu = Ak[dimension, dimension]  # Use bottom-right element as shift\n",
    "        Q, R = qr_manual(Ak - mu * L)  # シフトを適用\n",
    "        Ak1 = R * Q + mu * L\n",
    "        \n",
    "        if norm(Ak1 - Ak, Inf) < tol * norm(Ak, Inf)\n",
    "            eigenvalues[1:dimension] = diag(Ak1)\n",
    "            break\n",
    "        end\n",
    "        \n",
    "        Ak = Ak1\n",
    "    end\n",
    "    \n",
    "    # If loop finished without full deflation\n",
    "    if dimension > 0\n",
    "        eigenvalues[1:dimension] = diag(Ak)\n",
    "    end\n",
    "    \n",
    "    # Compute eigenvectors using inverse iteration\n",
    "    for k in 1:n\n",
    "        mu = eigenvalues[k]\n",
    "        _, v_k = invEigen(A, mu, 1000, tol)\n",
    "        eigenvectors[:, k] = v_k\n",
    "    end\n",
    "    \n",
    "    return eigenvalues, eigenvectors, itr\n",
    "end\n",
    "\n",
    "function qr_manual(A)\n",
    "    n = size(A, 1)\n",
    "    Q = copy(A)\n",
    "    R = Matrix{eltype(A)}(I, n, n)\n",
    "    # Gram–Schmidt\n",
    "    for k = 1:n\n",
    "        for j = 1:k-1\n",
    "            R[j, k] = dot(Q[:, j], Q[:, k])\n",
    "            Q[:, k] .-= R[j, k] * Q[:, j]\n",
    "        end\n",
    "        R[k, k] = norm(Q[:, k])\n",
    "        Q[:, k] /= R[k, k]\n",
    "    end\n",
    "    return Q, R\n",
    "end\n",
    "\n",
    "function invEigen(A, mu, max_iter=1000, tol=1e-12)\n",
    "    n = size(A, 1)\n",
    "    ε = 1e-6  # Increase shift to avoid near-singular matrices\n",
    "    \n",
    "    # Create shifted matrix and check for NaN/Inf\n",
    "    A_shifted = A - (mu + ε) * I\n",
    "    if any(isnan, A_shifted) || any(isinf, A_shifted)\n",
    "        # If matrix is bad, return approximate eigenvector\n",
    "        b_k = rand(n)\n",
    "        b_k /= norm(b_k)\n",
    "        λ = dot(b_k, A * b_k) / dot(b_k, b_k)\n",
    "        return λ, b_k\n",
    "    end\n",
    "    \n",
    "    # Try LU factorization with error handling\n",
    "    \n",
    "    F = lu(A_shifted)\n",
    "    b_k = rand(n)\n",
    "    b_k /= norm(b_k)\n",
    "    for _ in 1:max_iter\n",
    "        y = F \\ b_k\n",
    "        # Check for NaN/Inf in result\n",
    "        if any(isnan, y) || any(isinf, y)\n",
    "            break\n",
    "        end\n",
    "        y /= norm(y)\n",
    "        if norm(y - b_k) < tol\n",
    "            b_k = y\n",
    "            break\n",
    "        end\n",
    "        b_k = y\n",
    "    end\n",
    "    λ = dot(b_k, A * b_k) / dot(b_k, b_k)\n",
    "    return λ, b_k\n",
    "\n",
    "end\n",
    "\n",
    "\n",
    "function exp6(N; num_trials=100)\n",
    "    eigenvalues = zeros(num_trials, N)\n",
    "    times       = zeros(num_trials)\n",
    "    max_resnorms    = zeros(num_trials)\n",
    "    max_relerrs_lambda = zeros(num_trials)\n",
    "    itrs           = zeros(Int, num_trials)\n",
    "\n",
    "    for t in 1:num_trials\n",
    "        A = rand(N,N)\n",
    "        A = (A + A') / 2\n",
    "        λref = sort(eigen(A).values)\n",
    "        times[t] = @elapsed begin\n",
    "            λ, V, itr = qrEigens_fast(A)\n",
    "        end\n",
    "        eigenvalues[t, :] = λ\n",
    "        itrs[t] = itr\n",
    "        \n",
    "        # 式(2.58): max_i ||(A - λ_i I)v_i||\n",
    "        resnorms_i = zeros(N)\n",
    "        for i in 1:N\n",
    "            v_i = V[:, i]\n",
    "            resnorms_i[i] = norm(A * v_i - λ[i] * v_i)\n",
    "        end\n",
    "        max_resnorms[t] = maximum(resnorms_i)\n",
    "        \n",
    "        # 式(2.59): max_i |λ_i - λ̂_i| / |λ_i|\n",
    "        λ_sorted = sort(λ)\n",
    "        relerrs_i = abs.(λ_sorted .- λref) ./ abs.(λref)\n",
    "        max_relerrs_lambda[t] = maximum(relerrs_i)\n",
    "    end\n",
    "    (; max_resnorms, max_relerrs_lambda, times, itrs)\n",
    "end\n",
    "\n",
    "\n",
    "\n",
    "function plot_exp6(N, num_trials; saveprefix=\"exp6_n$(N)\")\n",
    "    r = exp6(N; num_trials=num_trials)\n",
    "    t = 1:num_trials\n",
    "    medianline(x) = begin\n",
    "        # x can be an array of values; compute median excluding NaNs\n",
    "        y = filter(!isnan, collect(x))\n",
    "        isempty(y) ? fill(NaN, num_trials) : fill(median(y), num_trials)\n",
    "    end\n",
    "\n",
    "    p1 = Plots.scatter(t, r.max_resnorms; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"max residual norm\",\n",
    "        title=\"Max Residual norm by QR Algorithm (Fast)  n=$N\")\n",
    "    Plots.plot!(p1, t, medianline(median(r.max_resnorms)); l=:dash)\n",
    "    Plots.annotate!(p1, [(50, median(r.max_resnorms), Plots.text(\"$(round(median(r.max_resnorms), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p1, \"graphs/$(saveprefix)_max_residual.png\")\n",
    "\n",
    "    p2 = Plots.scatter(t, r.max_relerrs_lambda; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"max relative error (eigenvalue)\",\n",
    "        title=\"Max Relative error (eigenvalue) by QR Algorithm (Fast)  n=$N\")\n",
    "    Plots.plot!(p2, t, medianline(median(r.max_relerrs_lambda)); l=:dash)\n",
    "    Plots.annotate!(p2, [(50, median(r.max_relerrs_lambda), Plots.text(\"$(round(median(r.max_relerrs_lambda), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p2, \"graphs/$(saveprefix)_max_relerr_eigenvalue.png\")\n",
    "\n",
    "    p3 = Plots.scatter(t, r.times; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"time [sec]\",\n",
    "        title=\"Runtime by QR Algorithm (Fast)  n=$N\")\n",
    "    Plots.plot!(p3, t, medianline(median(r.times)); l=:dash)\n",
    "    Plots.annotate!(p3, [(50, median(r.times), Plots.text(\"$(round(median(r.times), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p3, \"graphs/$(saveprefix)_time.png\")\n",
    "\n",
    "    p4 = Plots.scatter(t, r.itrs; legend=false,\n",
    "        xlabel=\"trials\", ylabel=\"iterations\",\n",
    "        title=\"Iterations by QR Algorithm (Fast)  n=$N\")\n",
    "    Plots.plot!(p4, t, medianline(median(r.itrs)); l=:dash)\n",
    "    Plots.annotate!(p4, [(50, median(r.itrs), Plots.text(\"$(round(median(r.itrs), sigdigits=3))\", 8, :left))])\n",
    "    Plots.savefig(p4, \"graphs/$(saveprefix)_iterations.png\")\n",
    "\n",
    "    # return medians for summary table\n",
    "    median_no_nan(x) = begin\n",
    "        vals = collect(filter(isfinite, x))\n",
    "        isempty(vals) ? NaN : median(vals)\n",
    "    end\n",
    "\n",
    "    m_res  = median_no_nan(r.max_resnorms)\n",
    "    m_rel  = median_no_nan(r.max_relerrs_lambda)\n",
    "    m_time = median_no_nan(r.times)\n",
    "    m_itrs = median_no_nan(r.itrs)\n",
    "    return (m_res, m_rel, m_time, m_itrs)\n",
    "end\n",
    "\n",
    "# Run experiments and save results\n",
    "Ns = [10, 20, 40, 80]\n",
    "results = []\n",
    "\n",
    "for N in Ns\n",
    "    m_res, m_rel, m_time, m_itrs = plot_exp6(N, 100)\n",
    "    push!(results, (N, m_res, m_rel, m_time, m_itrs))\n",
    "end\n",
    "\n",
    "# Print table from saved results\n",
    "@printf(\"\\n%6s | %15s | %20s | %12s | %10s\\n\", \"N\", \"median_resnorm\", \"median_relerr_eigenvalue\", \"median_time(s)\", \"median_iters\")\n",
    "println(repeat(\"-\", 80))\n",
    "for (N, m_res, m_rel, m_time, m_itrs) in results\n",
    "    @printf(\"%6d | %15.6e | %20.6e | %12.6f | %10.2f\\n\", N, m_res, m_rel, m_time, m_itrs)\n",
    "end\n"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Julia 1.12.0",
   "language": "julia",
   "name": "julia-1.12"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.12.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
