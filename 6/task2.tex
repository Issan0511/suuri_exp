\subsection{実装}

課題1で設計した分枝アルゴリズム（全単純路列挙に基づく最短路探索）を Python で実装した。探索は深さ優先探索（DFS）で行い、現在の経路 $P$ をスタックとして保持する。次に進む候補頂点 $v$ について「$v \notin P$（経路上で未訪問）」を満たすもののみに再帰的に進むことで単純路制約を満たす。

探索ノード数は、DFS の再帰呼び出し回数（すなわち「探索木において生成された部分問題の数」）として定義し、DFS 関数に入るたびにカウンタを 1 増やすことで計測した。実行時間は \texttt{time.process\_time()} により CPU 時間を測定し、ミリ秒に変換した。

グラフは節点数 $n$ と枝数 $m$ を指定して疑似乱数で生成した。候補となる有向枝（自己ループ除く）の集合をシャッフルし、その先頭から $m$ 本を採用することで「ちょうど $m$ 本の枝をランダムに張る」手続きを実現した。始点 $s=0$、終点 $t=n-1$ とし、$(s,t)$ が含まれない場合は追加して路の存在を保証した。枝重みは整数の一様乱数（例：$[-10,10]$）で与えた。乱数によるばらつきが生じるため、各 $(n,m)$ について 5 回試行し、実行時間と探索ノード数の平均および標準偏差を算出した。

\subsection{結果}

枝数は $m = \frac{n(n-1)}{2}$ とし、$n=5$ から $15$ まで計測した。結果を表1に示す。

\begin{table}[h]
\centering
\caption{実行時間と探索ノード数（平均±標準偏差、試行回数5）}
\begin{tabular}{r|r|r|r|r}
\hline
$n$ & time\_mean (ms) & time\_std (ms) & nodes\_mean & nodes\_std \\
\hline
5 & 0.00 & 0.00 & 7.4 & 2.2 \\
6 & 0.00 & 0.00 & 18.4 & 3.6 \\
7 & 0.00 & 0.00 & 34.8 & 14.8 \\
8 & 0.00 & 0.00 & 119.8 & 51.8 \\
9 & 0.00 & 0.00 & 414.0 & 251.0 \\
10 & 3.12 & 6.25 & 1276.6 & 215.5 \\
11 & 3.12 & 6.25 & 6103.2 & 1687.0 \\
12 & 15.62 & 0.00 & 34643.0 & 13605.0 \\
13 & 109.38 & 46.35 & 160508.6 & 65819.5 \\
14 & 534.38 & 142.32 & 820563.0 & 248673.9 \\
15 & 4556.25 & 1465.38 & 7437024.2 & 2220241.9 \\
\hline
\end{tabular}
\end{table}

節点数が増加するにつれて探索ノード数が急増し、それに伴って実行時間も急激に増大した。特に $n=12$ 以降で増加が顕著であり、$n=15$ では探索ノード数が約 $7.4\times 10^6$、実行時間が約 4.6 秒となった。

\subsection{考察}

\subsubsection{探索ノード数が急増する理由}

本実装は「単純路をすべて列挙し、その中で最短を選ぶ」方式であり、探索量はグラフ構造に強く依存する。今回 $m = \frac{n(n-1)}{2}$ と比較的密なグラフを用いたため、各頂点からの分岐数が大きくなりやすい。単純路の候補は「次に進める未訪問頂点」の選択の組合せで増えるため、節点数が増えると探索木の葉（候補経路）の数が指数的に増大する。表1でも $n$ の増加に対して nodes\_mean が桁を跨いで増えており、全探索が現実的でなくなる様子が定量的に確認できる。

\subsubsection{実行時間と探索ノード数の関係}

DFS 呼び出し回数（探索ノード数）は「列挙過程で実際に生成した部分問題数」に対応しており、実行時間は概ね探索ノード数に比例して増加すると考えられる。実測でも $n=10$ から $15$ で nodes\_mean が約 $1.3\times 10^3$ → $7.4\times 10^6$ と増えるにつれて、time\_mean も 3.12ms → 4556.25ms と大きく増加している。したがって、計算時間のボトルネックは主に探索量そのもの（列挙した部分問題数）であると言える。

